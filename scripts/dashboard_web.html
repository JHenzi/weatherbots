<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Trader Live</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; }
        .card { background-color: #1e293b; border: 1px solid #334155; }
        .trend-up { color: #f87171; }
        .trend-down { color: #60a5fa; }
    </style>
</head>
<body class="p-6">
    <div class="max-w-7xl mx-auto">
        <header class="flex justify-between items-center mb-8">
            <div class="flex items-center gap-4">
                <h1 class="text-3xl font-bold text-blue-400">Weather Trader <span class="text-white text-sm font-normal ml-2">Live Terminal</span></h1>
                <a href="/markets" class="text-cyan-400 hover:text-cyan-300 text-sm font-medium">New Markets</a>
                <a href="/analytics" class="text-cyan-400 hover:text-cyan-300 text-sm font-medium">Analytics</a>
            </div>
            <div id="last-updated" class="text-slate-400 text-sm" title="NWS timestamps are UTC; displayed in your local timezone">Initializing...</div>
        </header>

        <!-- City Cards (with Sun Tracker in each card) -->
        <div id="city-cards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
            <!-- Cards populated by JS -->
        </div>

        <!-- Next trade predictions (second box after weather) -->
        <section class="card rounded-xl p-6 mb-8">
            <h2 class="text-xl font-semibold mb-4 flex items-center">
                <span class="w-3 h-3 bg-violet-500 rounded-full mr-2"></span>
                Next trade — predictions, confidence, sources &amp; weights
            </h2>
            <p class="text-slate-400 text-sm mb-4">Model prediction for the next trade date per city. Each column is that source's forecast (°F). Color: cold → mild → warm. <span id="predictions-last-run" class="text-slate-500"></span></p>
            <div id="predictions-table-wrap" class="overflow-x-auto">
                <!-- Populated by JS -->
            </div>
        </section>

        <!-- Risk / Sell Advisor and At Risk (moved up) -->
        <section class="card rounded-xl p-6 mb-8">
            <h2 class="text-xl font-semibold mb-4 text-amber-400">Risk / Sell Advisor</h2>
            <p class="text-slate-500 text-xs mb-3">Desktop alerts when a position is flagged. <button type="button" id="enable-notifications-btn" class="text-amber-400 hover:underline">Enable notifications</button></p>
            <div id="hedge-signals" class="space-y-4">
                <div class="text-slate-500 italic text-center py-8">Scanning for signals...</div>
            </div>
            <section class="mt-8">
                <h3 class="text-lg font-semibold mb-3 text-cyan-400">At-risk brackets (BUY NO)</h3>
                <p class="text-slate-500 text-xs mb-3">Only shown when we have edge: consensus doesn’t match bracket, few sources in range, and good expected value. Pick the one with best value below.</p>
                <div id="at-risk-brackets" class="space-y-4">
                    <div class="text-slate-500 italic text-center py-4">Scanning...</div>
                </div>
            </section>
        </section>

        <!-- Positions: projection, risk, forecast, confidence & P/L in one place -->
        <section class="card rounded-xl p-6 mb-8">
            <h2 class="text-xl font-semibold mb-1 flex items-center">
                <span class="w-3 h-3 bg-emerald-500 rounded-full mr-2"></span>
                Positions
            </h2>
            <p class="text-slate-400 text-sm mb-6">Per position: projection, risk, rate (°/hr), forecast, confidence, P/L. One card per bet — no duplicate tables.</p>
            <div id="positions-combined" class="space-y-4">
                <!-- Populated by JS: one card per position -->
            </div>
        </section>
    </div>

    <script>
        const API_BASE = '/api';

        function escapeHtml(s) {
            if (s == null) return '';
            const div = document.createElement('div');
            div.textContent = String(s);
            return div.innerHTML;
        }

        // Desktop notifications for urgent Risk/Sell signals (throttle 5 min per position)
        const URGENT_NOTIFY_THROTTLE_MS = 5 * 60 * 1000;
        let lastUrgentNotifyByTicker = {};
        // At-risk bracket BUY NO notifications (throttle 5 min per suggested ticker)
        let lastAtRiskNotifyByTicker = {};

        function showUrgentDesktopNotification(pos, bucketBase, minsToBreak) {
            if (!('Notification' in window)) return;
            const ticker = pos.ticker || pos.market_ticker || '';
            const now = Date.now();
            if (lastUrgentNotifyByTicker[ticker] && (now - lastUrgentNotifyByTicker[ticker]) < URGENT_NOTIFY_THROTTLE_MS) return;

            if (Notification.permission === 'granted') {
                lastUrgentNotifyByTicker[ticker] = now;
                const city = (pos.city || '').toUpperCase();
                const body = `${city} warming ${(pos.trend_1h != null ? pos.trend_1h.toFixed(1) : '')}°/hr. Bucket ${bucketBase}-${bucketBase + 1} in ~${minsToBreak} mins. Consider selling.`;
                new Notification('Weather Trader — Urgent', { body, icon: '/favicon.ico' }).onclick = () => window.focus();
            } else if (Notification.permission !== 'denied') {
                Notification.requestPermission().then(p => { if (p === 'granted') showUrgentDesktopNotification(pos, bucketBase, minsToBreak); });
            }
        }

        function showAtRiskBracketNotification(item) {
            if (!('Notification' in window)) return;
            const ticker = item.suggested_ticker || '';
            const now = Date.now();
            if (lastAtRiskNotifyByTicker[ticker] && (now - lastAtRiskNotifyByTicker[ticker]) < URGENT_NOTIFY_THROTTLE_MS) return;
            if (Notification.permission === 'granted') {
                lastAtRiskNotifyByTicker[ticker] = now;
                const city = (item.city || '').toUpperCase();
                const body = `${city} ${item.bucket_base}-${item.bracket_high}° bracket at risk (warming ${item.trend_30m.toFixed(1)}°/hr, proj high ${item.projected_high}°). Consider BUY NO on ${ticker} if priced well.`;
                new Notification('Weather Trader — BUY NO opportunity', { body, icon: '/favicon.ico' }).onclick = () => window.focus();
            } else if (Notification.permission !== 'denied') {
                Notification.requestPermission().then(p => { if (p === 'granted') showAtRiskBracketNotification(item); });
            }
        }

        async function updateDashboard() {
            try {
                const [obsRes, posRes, predRes, intradayRes, sunRes, atRiskRes] = await Promise.all([
                    fetch(API_BASE + '/observations'),
                    fetch(API_BASE + '/positions'),
                    fetch(API_BASE + '/predictions'),
                    fetch(API_BASE + '/intraday'),
                    fetch(API_BASE + '/sun'),
                    fetch(API_BASE + '/at_risk_brackets')
                ]);

                const obsData = await obsRes.json();
                const posData = await posRes.json();
                const predData = await predRes.json();
                const intradayData = await intradayRes.json();
                const sunData = await sunRes.json();
                const atRiskData = await atRiskRes.json();

                const stations = obsData.stations || {};
                const positions = (posData.positions || posData) || [];
                const posError = posData.error || null;
                renderCityCards(stations, sunData);
                const predictionsList = Array.isArray(predData) ? predData : (predData.predictions || []);
                const predictionsPayload = { predictions: predictionsList, last_run: predData.last_run, display_date: predData.display_date };
                renderPositionsCombined(positions, stations, predictionsList, intradayData, sunData, posError);
                renderPredictionsTable(predictionsPayload);
                renderHedges(positions, stations, predictionsList);
                renderAtRiskBrackets(atRiskData);
                
                const lastTs = obsData.last_update ? new Date(obsData.last_update) : null;
                document.getElementById('last-updated').textContent = lastTs
                    ? 'Observations updated: ' + lastTs.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit', second: '2-digit', timeZoneName: 'short' })
                    : 'Last refresh: ' + new Date().toLocaleTimeString();
            } catch (err) {
                console.error('Fetch error:', err);
                document.getElementById('last-updated').textContent = 'API Offline';
            }
        }

        // NWS observations are UTC; we display in viewer's local time and show timezone.
        function formatObsTime(isoStr) {
            if (!isoStr) return '—';
            const d = new Date(isoStr);
            return d.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit', second: '2-digit', timeZoneName: 'short' });
        }

        function renderCityCards(stations, sunData) {
            const container = document.getElementById('city-cards');
            const cityNames = { 'ny': 'New York', 'il': 'Chicago', 'tx': 'Austin', 'fl': 'Miami' };
            const byCity = (sunData && sunData.by_city) ? sunData.by_city : {};
            if (!stations || Object.keys(stations).length === 0) {
                container.innerHTML = '<div class="col-span-full card rounded-xl p-6 text-slate-500 text-center">Waiting for observations…</div>';
                return;
            }
            container.innerHTML = '';
            const now = new Date();
            Object.entries(stations).forEach(([key, data]) => {
                const sun = byCity[key];
                const progress = sun ? sun.progress : 0;
                const status = sun ? sun.status : '—';
                const trendIcon = data.trend_1h > 0 ? '↑' : '↓';
                const trendClass = data.trend_1h > 0 ? 'trend-up' : 'trend-down';
                const obsTime = formatObsTime(data.timestamp);
                const highToday = data.observed_high_today != null ? data.observed_high_today : data.temp;
                const nowTemp = data.temp;
                const pastPeak = sun && sun.past_peak;
                const highTitle = pastPeak
                    ? 'Daily high (final for today, from hourly obs — matches NWS timeseries)'
                    : 'Max observed so far today (hourly obs, matches NWS timeseries)';
                const trendPerHr = (data.trend_30m != null && data.trend_30m !== '') ? parseFloat(data.trend_30m) : (data.trend_1h != null ? parseFloat(data.trend_1h) : 0);
                let projLine = '';
                if (sun && sun.high_time && !pastPeak) {
                    try {
                        const highTime = new Date(sun.high_time);
                        const minsUntilPeak = Math.round((highTime - now) / 60000);
                        if (minsUntilPeak > 0) {
                            const projected = nowTemp + trendPerHr * (minsUntilPeak / 60);
                            projLine = `<div class="text-sm text-slate-300 mt-1" title="Projected from current temp + trend">${Math.round(projected)}° in ${minsUntilPeak}m</div>`;
                        } else {
                            projLine = `<div class="text-sm text-slate-500 mt-1">${nowTemp.toFixed(1)}° now</div>`;
                        }
                    } catch (e) {
                        projLine = '';
                    }
                } else if (pastPeak) {
                    projLine = `<div class="text-sm text-slate-500 mt-1">Now ${nowTemp.toFixed(1)}° — peak passed, high is set</div>`;
                }
                const nwsTimeseriesUrl = `https://www.weather.gov/wrh/timeseries?site=${data.stid}&hourly=true&units=english`;
                const mainLabel = pastPeak
                    ? `Daily high <span class="text-slate-300">${highToday.toFixed(1)}°</span> <span class="text-slate-500 text-base font-normal">(set)</span>`
                    : `${highToday.toFixed(1)}°F${highToday === nowTemp ? '' : ` <span class="text-slate-500 font-normal text-lg">(now ${nowTemp.toFixed(1)}°)</span>`}`;
                container.innerHTML += `
                    <div class="card rounded-xl p-4">
                        <div class="flex justify-between items-start mb-2">
                            <span class="text-slate-400 font-medium">${cityNames[key]}</span>
                            <a href="${nwsTimeseriesUrl}" target="_blank" rel="noopener" class="text-xs bg-slate-700 px-2 py-1 rounded text-slate-300 hover:text-amber-400" title="Compare: NWS Time Series (hourly) vs our observed high">${data.stid} ↗</a>
                        </div>
                        <div class="text-3xl font-bold mb-1" title="${highTitle}">${mainLabel}</div>
                        ${projLine}
                        <div class="flex items-center text-sm mt-1">
                            <span class="${trendClass} font-bold mr-1">${trendIcon}</span>
                            <span class="${trendClass}">${Math.abs(data.trend_1h).toFixed(2)}°/hr</span>
                            <span class="text-slate-500 ml-2">(${Math.abs(data.trend_10m).toFixed(2)} 10m)</span>
                        </div>
                        <div class="mt-2 pt-2 border-t border-slate-700 flex items-center justify-between">
                            <span class="text-xs text-amber-400/90" title="Warming cycle progress">☀ ${progress}%</span>
                            <span class="text-xs text-slate-500">${status}</span>
                        </div>
                        <div class="text-xs text-slate-500 mt-1" title="Observed high = max of hourly observations today (matches NWS timeseries). Last obs at ${obsTime}">Last obs ${obsTime}</div>
                    </div>
                `;
            });
        }

        async function placeOrder(ticker, side, action, count, price) {
            if (!confirm(`Are you sure you want to ${action} ${count} ${side.toUpperCase()} shares for ${ticker} at ${price}¢?`)) {
                return;
            }

            try {
                const resp = await fetch(API_BASE + '/trade/order', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ticker, side, action, count, price })
                });
                
                const data = await resp.json();
                if (resp.ok) {
                    alert('Order submitted successfully!');
                    updateDashboard();
                } else {
                    alert('Order failed: ' + (data.detail || 'Unknown error'));
                }
            } catch (err) {
                console.error('Order error:', err);
                alert('API error while submitting order');
            }
        }

        // Limit sell: place a limit order to sell YES at a chosen price (prompts for price).
        function limitSellOrder(ticker, count, defaultPrice) {
            const priceStr = prompt('Limit sell price (¢):', String(defaultPrice || 1));
            if (priceStr == null || priceStr === '') return;
            const price = parseInt(priceStr, 10);
            if (isNaN(price) || price < 1 || price > 99) {
                alert('Enter a valid price between 1 and 99¢');
                return;
            }
            placeOrder(ticker, 'yes', 'sell', count, price);
        }

        const cityLabels = { 'ny': 'NY', 'il': 'Chicago', 'tx': 'Austin', 'fl': 'Miami' };

        // KXHIGHNY-26JAN29-B27.5 -> 2026-01-29
        function parseEventTradeDate(ticker) {
            if (!ticker) return null;
            const match = ticker.match(/-(\d{2})(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(\d{2})/i);
            if (!match) return null;
            const months = { JAN:1,FEB:2,MAR:3,APR:4,MAY:5,JUN:6,JUL:7,AUG:8,SEP:9,OCT:10,NOV:11,DEC:12 };
            const y = parseInt(match[1], 10);
            const year = y < 50 ? 2000 + y : 1900 + y;
            const month = months[match[2].toUpperCase()];
            const day = parseInt(match[3], 10);
            if (!month) return null;
            const m = String(month).padStart(2, '0');
            const d = String(day).padStart(2, '0');
            return `${year}-${m}-${d}`;
        }

        function getPredictionFor(predictions, city, tradeDate) {
            if (!Array.isArray(predictions) || !tradeDate) return null;
            const row = predictions.find(p => (p.date === tradeDate || p.trade_date === tradeDate) && (p.city === city));
            if (!row || row.tmax_predicted === undefined || row.tmax_predicted === '') return null;
            const v = parseFloat(row.tmax_predicted);
            return isNaN(v) ? null : v;
        }

        function getIntradayFor(intradayData, city, tradeDate) {
            if (!intradayData || !intradayData.by_city_date) return null;
            const byCity = intradayData.by_city_date[city];
            if (!byCity) return null;
            const row = byCity[tradeDate];
            if (!row || row.mean_forecast == null) return null;
            return { mean_forecast: row.mean_forecast, current_sigma: row.current_sigma, timestamp: row.timestamp };
        }

        function getSunStatusForCity(sunData, city) {
            const byCity = (sunData && sunData.by_city) ? sunData.by_city : {};
            const s = byCity[city];
            if (s) return s.past_peak ? 'Has peaked' : 'Yet to peak';
            return '—';
        }

        function getPredictionRow(predictions, city, tradeDate) {
            if (!Array.isArray(predictions) || !tradeDate) return null;
            return predictions.find(p => (p.date === tradeDate || p.trade_date === tradeDate) && (p.city === city)) || null;
        }

        function getProjection(obs, sunCity) {
            // Fallback when API doesn't have projected_high (e.g. old cache). Prefer obs.projected_high from backend.
            if (!obs) return null;
            const nowTemp = obs.temp;
            const obsHigh = obs.observed_high_today != null ? obs.observed_high_today : nowTemp;
            const trendPerHr = (obs.trend_1h != null && obs.trend_1h !== '') ? parseFloat(obs.trend_1h) : 0;
            if (!sunCity || sunCity.past_peak) return obsHigh;
            if (trendPerHr <= 0) return obsHigh; // cooling: high is already set, don't project above obs
            if (!sunCity.high_time) return nowTemp;
            try {
                const highTime = new Date(sunCity.high_time);
                const now = new Date();
                const hoursUntilPeak = Math.max(0, (highTime - now) / 3600000);
                const proj = Math.round((nowTemp + trendPerHr * hoursUntilPeak) * 10) / 10;
                return Math.max(proj, obsHigh); // never project below observed high so far
            } catch (e) {
                return nowTemp;
            }
        }

        function renderPositionsCombined(positions, stations, predictions, intradayData, sunData, posError) {
            const container = document.getElementById('positions-combined');
            if (!container) return;

            if (posError) {
                container.innerHTML = '<div class="rounded-lg border border-amber-500/50 bg-amber-500/10 px-4 py-6 text-center text-amber-400">' + escapeHtml(posError) + '</div>';
                return;
            }
            if (!positions || positions.length === 0) {
                container.innerHTML = '<div class="rounded-lg border border-slate-600 bg-slate-800/50 px-4 py-8 text-center text-slate-500">No open positions — live from Kalshi.</div>';
                return;
            }

            const byCitySun = (sunData && sunData.by_city) ? sunData.by_city : {};
            let html = '';

            positions.forEach(pos => {
                const ticker = pos.ticker || pos.event_ticker || '';
                const bucketMatch = ticker.match(/-B(\d+\.?\d*)/) || ticker.match(/-T(\d+\.?\d*)/);
                const bucketBase = bucketMatch ? parseFloat(bucketMatch[1]) : null;
                const isTopBucket = ticker.includes('-T');
                const bracketHigh = bucketBase != null ? (isTopBucket ? null : bucketBase + 1) : null;
                const tradeDate = parseEventTradeDate(ticker);
                const city = pos.city || '';
                const predRow = getPredictionRow(predictions, city, tradeDate);
                const pred = predRow && predRow.tmax_predicted != null && predRow.tmax_predicted !== '' ? parseFloat(predRow.tmax_predicted) : null;
                const confidence = predRow && predRow.confidence_score != null && predRow.confidence_score !== '' ? parseFloat(predRow.confidence_score) : null;
                const intraday = getIntradayFor(intradayData, city, tradeDate);
                const obs = stations[city];
                const obsHigh = obs && (obs.observed_high_today != null || obs.temp != null) ? (obs.observed_high_today != null ? obs.observed_high_today : obs.temp) : null;
                const nowTemp = obs ? obs.temp : null;
                const trend1h = obs ? obs.trend_1h : null;
                const trend30m = obs && (obs.trend_30m != null && obs.trend_30m !== '') ? parseFloat(obs.trend_30m) : trend1h;

                const forecastVal = intraday ? intraday.mean_forecast : null;
                // Use backend projected_high when present (single source of truth); fallback to local getProjection
                const projection = (obs && obs.projected_high != null && obs.projected_high !== '') ? parseFloat(obs.projected_high) : getProjection(obs, byCitySun[city]);
                const sunStatus = getSunStatusForCity(sunData, city);

                let inRange = '—';
                if (bucketBase != null && obsHigh != null) {
                    if (isTopBucket) inRange = obsHigh >= bucketBase ? 'Yes' : 'No';
                    else inRange = (obsHigh >= bucketBase && obsHigh < bucketBase + 1) ? 'Yes' : 'No';
                }
                const trendClass = trend1h > 0 ? 'trend-up' : trend1h < 0 ? 'trend-down' : 'text-slate-400';
                const trendSign = trend1h > 0 ? '+' : '';
                const trendStr = trend1h != null ? trendSign + trend1h.toFixed(2) + '°/hr' : '—';

                let riskLabel = '—';
                let riskClass = 'text-slate-400';
                let riskBg = 'bg-slate-700';
                let riskBorder = 'border-l-slate-600';
                if (obs && bucketBase != null && trend1h != null && obsHigh != null) {
                    const d = obsHigh - bucketBase;
                    const movingTowardEdge = (d < 0 && trend1h > 0) || (d > 0 && trend1h < 0);
                    if (Math.abs(d) < 1.0 && movingTowardEdge) { riskLabel = 'HIGH'; riskClass = 'text-red-400 font-bold'; riskBg = 'bg-red-500/20'; riskBorder = 'border-l-red-500'; }
                    else if (Math.abs(d) < 2.0) { riskLabel = 'MED'; riskClass = 'text-amber-400'; riskBg = 'bg-amber-500/20'; riskBorder = 'border-l-amber-500'; }
                    else { riskLabel = 'LOW'; riskClass = 'text-green-400'; riskBg = 'bg-green-500/20'; riskBorder = 'border-l-emerald-500'; }
                }

                const count = pos.position != null ? pos.position : (pos.count || 0);
                const positionFp = parseFloat(pos.position_fp);
                const yesBid = pos.yes_bid != null ? parseInt(pos.yes_bid, 10) : null;
                const costDollars = !isNaN(positionFp) ? (count * positionFp / 100) : null;
                const pnlNowDollars = (yesBid != null && !isNaN(positionFp) && costDollars != null) ? (count * yesBid / 100 - costDollars) : null;
                const pnlIfWonDollars = !isNaN(positionFp) ? (count * (100 - positionFp) / 100) : null;
                const pnlNowStr = pnlNowDollars != null ? '$' + pnlNowDollars.toFixed(2) : '—';
                const pnlIfWonStr = pnlIfWonDollars != null ? '$' + pnlIfWonDollars.toFixed(2) : '—';
                const pnlNowClass = pnlNowDollars != null ? (pnlNowDollars >= 0 ? 'text-green-400' : 'text-red-400') : 'text-slate-400';
                const bidAsk = (pos.yes_bid != null && pos.yes_ask != null) ? (pos.yes_bid + '¢ / ' + pos.yes_ask + '¢') : '—';

                const cityName = cityLabels[city] || city;
                const bucketLabel = bracketHigh != null ? bucketBase + '–' + bracketHigh + '°' : (bucketBase != null ? bucketBase + '°+' : '—');
                const subtitle = pos.market_subtitle ? (' — ' + (pos.market_subtitle || '').slice(0, 40)) : '';

                html += '<div class="rounded-xl border border-slate-600 border-l-4 ' + riskBorder + ' bg-slate-800/60 overflow-hidden hover:border-slate-500 transition-colors">';
                html += '  <div class="flex flex-wrap items-start justify-between gap-3 p-4 sm:p-5">';
                html += '    <div class="min-w-0 flex-1">';
                html += '      <div class="flex flex-wrap items-center gap-2 mb-3">';
                html += '        <span class="font-semibold text-slate-200">' + escapeHtml(cityName) + '</span>';
                html += '        <span class="text-slate-500 font-mono text-sm">' + escapeHtml(bucketLabel) + '</span>';
                html += '        <span class="rounded-full px-2.5 py-0.5 text-xs font-semibold ' + riskBg + ' ' + riskClass + '">' + riskLabel + '</span>';
                html += '        <span class="text-slate-500 text-xs">' + sunStatus + '</span>';
                html += '      </div>';
                html += '      <div class="flex flex-wrap items-baseline gap-x-4 gap-y-1 text-sm">';
                html += '        <span class="text-slate-400">Pred</span><span class="font-mono ' + (pred != null ? predTempClass(pred) : '') + '">' + (pred != null ? pred.toFixed(1) + '°' : '—') + '</span>';
                html += '        <span class="text-slate-400">Forecast</span><span class="font-mono">' + (forecastVal != null ? forecastVal.toFixed(1) + '°' : '—') + '</span>';
                html += '        <span class="text-slate-400">Obs</span><span class="font-mono">' + (obsHigh != null ? obsHigh.toFixed(1) + '°' : '—') + '</span>';
                html += '        <span class="text-slate-400">Now</span><span class="font-mono">' + (nowTemp != null ? nowTemp.toFixed(1) + '°' : '—') + '</span>';
                html += '        <span class="text-slate-400">Rate</span><span class="font-mono ' + trendClass + '">' + trendStr + '</span>';
                html += '        <span class="text-slate-400">Proj</span><span class="font-mono font-semibold text-cyan-300">' + (projection != null ? projection.toFixed(1) + '°' : '—') + '</span>';
                html += '      </div>';
                html += '      <div class="mt-2 flex flex-wrap items-center gap-x-4 text-xs text-slate-500">';
                html += '        <span>Conf ' + (confidence != null ? confidence.toFixed(2) : '—') + '</span>';
                html += '        <span>In range ' + inRange + '</span>';
                html += '      </div>';
                html += '      <div class="mt-3 pt-3 border-t border-slate-700 flex flex-wrap items-center gap-x-6 text-sm">';
                html += '        <span class="text-slate-400">Size</span><span class="font-mono">' + count + '</span>';
                html += '        <span class="text-slate-400">Bid/Ask</span><span class="font-mono">' + bidAsk + '</span>';
                html += '        <span class="text-slate-400">P/L now</span><span class="font-mono font-semibold ' + pnlNowClass + '">' + pnlNowStr + '</span>';
                html += '        <span class="text-slate-400">P/L if won</span><span class="font-mono text-slate-300">' + pnlIfWonStr + '</span>';
                html += '      </div>';
                html += '    </div>';
                html += '    <div class="flex flex-col gap-2 shrink-0">';
                html += '      <button onclick="placeOrder(\'' + ticker.replace(/'/g, "\\'") + '\', \'yes\', \'sell\', ' + count + ', ' + (pos.yes_bid || 1) + ')" class="rounded-lg bg-slate-600 hover:bg-slate-500 px-4 py-2 text-sm font-semibold transition-colors" title="Sell at current bid">SELL</button>';
                html += '      <button onclick="limitSellOrder(\'' + ticker.replace(/'/g, "\\'") + '\', ' + count + ', ' + (pos.yes_bid != null ? pos.yes_bid : pos.yes_ask || 1) + ')" class="rounded-lg bg-slate-700 hover:bg-slate-600 px-4 py-2 text-sm font-semibold transition-colors" title="Limit sell at your price">LIMIT SELL</button>';
                html += '    </div>';
                html += '  </div>';
                html += '  <div class="px-4 sm:px-5 pb-3 text-xs font-mono text-slate-500 truncate" title="' + escapeHtml(ticker) + '">' + escapeHtml(ticker) + '</div>';
                html += '</div>';
            });
            container.innerHTML = html;
        }

        function predTempClass(temp) {
            if (temp == null || isNaN(temp)) return 'text-slate-400';
            const t = parseFloat(temp);
            if (t < 35) return 'text-blue-300';
            if (t < 55) return 'text-cyan-300';
            if (t < 75) return 'text-green-400';
            if (t < 90) return 'text-amber-400';
            return 'text-red-400';
        }

        const PRED_SOURCE_COLS = [
            { key: 'tmax_open_meteo', label: 'Open-Meteo', title: 'open-meteo' },
            { key: 'tmax_visual_crossing', label: 'VC', title: 'visual-crossing' },
            { key: 'tmax_tomorrow', label: 'Tomorrow', title: 'tomorrow' },
            { key: 'tmax_weatherapi', label: 'WeatherAPI', title: 'weatherapi' },
            { key: 'tmax_google_weather', label: 'Google', title: 'google-weather' },
            { key: 'tmax_openweathermap', label: 'OWM', title: 'openweathermap' },
            { key: 'tmax_pirateweather', label: 'Pirate', title: 'pirateweather' },
            { key: 'tmax_weather_gov', label: 'NWS', title: 'weather.gov' },
        ];

        function renderPredictionsTable(predData) {
            const wrap = document.getElementById('predictions-table-wrap');
            const lastRunEl = document.getElementById('predictions-last-run');
            if (!wrap) return;
            let rows = Array.isArray(predData) ? predData : (predData.predictions || []);
            const lastRunRaw = predData.last_run || null;
            const displayDate = (predData.display_date || '').trim() || null;
            if (lastRunEl) {
                if (lastRunRaw) {
                    try {
                        const d = new Date(lastRunRaw);
                        lastRunEl.textContent = 'Last run: ' + (isNaN(d.getTime()) ? lastRunRaw : d.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' }));
                    } catch (e) {
                        lastRunEl.textContent = 'Last run: ' + lastRunRaw;
                    }
                } else {
                    lastRunEl.textContent = '';
                }
            }
            // Prefer display_date (next trade date); if no rows for it, show latest date we have
            let tradeDate = displayDate;
            let fallbackNote = '';
            if (displayDate && rows.length) {
                const forDisplay = rows.filter(function(r) {
                    const d = (r.date || r.trade_date || '').toString().trim();
                    return d === displayDate;
                });
                if (forDisplay.length > 0) {
                    rows = forDisplay;
                } else {
                    // Requested date not in file — show latest date we have
                    const dates = [...new Set(rows.map(r => (r.date || r.trade_date || '').toString().trim()).filter(Boolean))].sort();
                    tradeDate = dates.length ? dates[dates.length - 1] : null;
                    rows = rows.filter(r => (r.date || r.trade_date || '').toString().trim() === tradeDate);
                    fallbackNote = ' <span class="text-amber-400/90">(next trade date ' + escapeHtml(displayDate) + ' not yet in file — run intraday pulse)</span>';
                }
            }
            if (!tradeDate && rows.length) {
                tradeDate = rows[0].date || rows[0].trade_date || null;
            }
            const cityOrder = ['ny', 'il', 'tx', 'fl'];
            const cityLabels = { 'ny': 'New York', 'il': 'Chicago', 'tx': 'Austin', 'fl': 'Miami' };
            const byCity = {};
            rows.forEach(r => { const c = (r.city || '').trim().toLowerCase(); if (c) byCity[c] = r; });
            const ordered = cityOrder.filter(c => byCity[c]).map(c => byCity[c]);
            if (ordered.length === 0) {
                const msg = tradeDate
                    ? 'No predictions for ' + escapeHtml(tradeDate) + ' yet — run intraday/trade pipeline or wait for next run.'
                    : 'No predictions yet — run intraday/trade pipeline to populate predictions_latest.';
                wrap.innerHTML = '<div class="text-slate-500 text-center py-6">' + msg + '</div>';
                return;
            }
            let html = '<table class="w-full text-left"><thead><tr class="text-slate-400 border-b border-slate-700">';
            html += '<th class="pb-2 pr-2">City</th>';
            html += '<th class="pb-2 pr-2" title="Predicted high °F">Pred</th>';
            html += '<th class="pb-2 pr-2">Conf</th>';
            html += '<th class="pb-2 pr-2" title="Spread / dispersion">Spread</th>';
            PRED_SOURCE_COLS.forEach(sc => {
                html += '<th class="pb-2 pr-2 text-center" title="' + escapeHtml(sc.title) + '">' + escapeHtml(sc.label) + '</th>';
            });
            html += '</tr></thead><tbody>';
            ordered.forEach(r => {
                const city = (r.city || '').trim().toLowerCase();
                const pred = r.tmax_predicted != null && r.tmax_predicted !== '' ? parseFloat(r.tmax_predicted) : null;
                const conf = r.confidence_score != null && r.confidence_score !== '' ? parseFloat(r.confidence_score) : null;
                const spread = r.spread_f != null && r.spread_f !== '' ? parseFloat(r.spread_f) : null;
                const predStr = pred != null ? pred.toFixed(1) + '°' : '—';
                const confStr = conf != null ? conf.toFixed(2) : '—';
                const spreadStr = spread != null ? spread.toFixed(2) : '—';
                const predClass = predTempClass(pred);
                html += '<tr class="border-b border-slate-800 hover:bg-slate-800/50">';
                html += '<td class="py-3 pr-2 font-medium">' + (cityLabels[city] || city) + '</td>';
                html += '<td class="py-3 pr-2 font-bold font-mono text-sm ' + predClass + '" title="Predicted high">' + predStr + '</td>';
                html += '<td class="py-3 pr-2 font-mono text-xs">' + confStr + '</td>';
                html += '<td class="py-3 pr-2 font-mono text-xs">' + spreadStr + '</td>';
                PRED_SOURCE_COLS.forEach(sc => {
                    const raw = r[sc.key];
                    const val = raw != null && raw !== '' ? parseFloat(raw) : null;
                    const cellStr = val != null ? val.toFixed(1) + '°' : '—';
                    const cellClass = predTempClass(val);
                    html += '<td class="py-3 pr-2 font-mono text-xs text-center ' + cellClass + '" title="' + escapeHtml(sc.title) + '">' + cellStr + '</td>';
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            const header = tradeDate ? '<p class="text-slate-500 text-sm mb-3">Trade date: <strong class="text-slate-300">' + escapeHtml(tradeDate) + '</strong>' + fallbackNote + '</p>' : '';
            wrap.innerHTML = header + html;
        }

        function renderHedges(positions, stations, predictions) {
            const container = document.getElementById('hedge-signals');
            container.innerHTML = '';

            let signalsFound = false;

            positions.forEach(pos => {
                const obs = stations[pos.city];
                if (!obs) return;

                const ticker = pos.ticker || pos.market_ticker;
                const bucketMatch = ticker.match(/-B(\d+\.?\d*)/);
                const bucketBase = bucketMatch ? parseFloat(bucketMatch[1]) : 0;
                const distance = obs.temp - bucketBase;
                
                // Signal if warming rapidly toward the upper edge
                if (distance > -1.5 && distance < 0 && obs.trend_1h > 1.0) {
                    signalsFound = true;
                    const minsToBreak = Math.round(Math.abs(distance / obs.trend_1h * 60));
                    // Fire desktop notification (throttled per ticker)
                    const posWithTrend = { ...pos, trend_1h: obs.trend_1h };
                    showUrgentDesktopNotification(posWithTrend, bucketBase, minsToBreak);
                    container.innerHTML += `
                        <div class="bg-red-900/20 border border-red-500/50 rounded-lg p-4">
                            <div class="flex justify-between items-start mb-2">
                                <span class="bg-red-500 text-white text-[10px] px-2 py-0.5 rounded-full font-bold">URGENT</span>
                                <span class="text-slate-400 text-xs">${new Date().toLocaleTimeString()}</span>
                            </div>
                            <p class="text-sm mb-3">
                                <strong>${pos.city.toUpperCase()}</strong> is warming at <strong>${obs.trend_1h.toFixed(1)}°/hr</strong>.
                                Projected to break bucket <strong>${bucketBase}-${bucketBase+1}</strong> in approx <strong>${minsToBreak} mins</strong>.
                                Reduce exposure by selling or placing a limit sell (hedging in other buckets is separate).
                            </p>
                            <div class="flex gap-2">
                                <button onclick="placeOrder('${ticker.replace(/'/g, "\\'")}', 'yes', 'sell', ${pos.position || 0}, ${pos.yes_bid != null ? pos.yes_bid : 1})" class="flex-1 bg-slate-600 hover:bg-slate-500 py-2 rounded font-bold transition-colors">SELL AT BID</button>
                                <button onclick="limitSellOrder('${ticker.replace(/'/g, "\\'")}', ${pos.position || 0}, ${pos.yes_bid != null ? pos.yes_bid : pos.yes_ask || 1})" class="flex-1 bg-red-600 hover:bg-red-500 py-2 rounded font-bold transition-colors">LIMIT SELL</button>
                            </div>
                        </div>
                    `;
                }
            });

            if (!signalsFound) {
                container.innerHTML = '<div class="text-slate-500 italic text-center py-8">No urgent sell signals. Markets are stable.</div>';
            }
        }

        function renderAtRiskBrackets(atRiskData) {
            const container = document.getElementById('at-risk-brackets');
            if (!container) return;
            const list = (atRiskData && atRiskData.at_risk) ? atRiskData.at_risk : [];
            if (list.length === 0) {
                container.innerHTML = '<div class="text-slate-500 italic text-center py-4">No at-risk brackets with edge. Projected high may not exceed bracket, or consensus matches / no good value.</div>';
                return;
            }
            const cityNames = { 'ny': 'New York', 'il': 'Chicago', 'tx': 'Austin', 'fl': 'Miami' };
            const bestHint = list.length > 1 ? '<p class="text-cyan-400/90 text-xs font-semibold mb-3">Pick the one with best value (prices from Kalshi):</p>' : '';
            container.innerHTML = bestHint;
            list.forEach(item => {
                showAtRiskBracketNotification(item);
                const name = cityNames[item.city] || item.city;
                const noAsk = item.no_ask != null ? item.no_ask + '¢' : '—';
                const evCents = item.ev_cents != null ? (item.ev_cents >= 0 ? '+' + item.ev_cents.toFixed(1) : item.ev_cents.toFixed(1)) + '¢ EV' : '';
                const bestBadge = item.best_value ? '<span class="ml-2 px-2 py-0.5 rounded text-xs font-semibold bg-cyan-500/30 text-cyan-300">Best value</span>' : '';
                const consensusLine = item.consensus_pred != null ? ` Consensus ${item.consensus_pred.toFixed(1)}°, ${item.sources_in_bracket != null ? item.sources_in_bracket : '?'} sources in bracket.` : '';
                container.innerHTML += `
                    <div class="bg-cyan-900/20 border rounded-lg p-4 ${item.best_value ? 'border-cyan-400 ring-1 ring-cyan-400/40' : 'border-cyan-500/50'}">
                        <div class="flex justify-between items-start mb-2 flex-wrap gap-2">
                            <span class="text-cyan-400 font-semibold">${name}${bestBadge}</span>
                            <span class="text-slate-400 text-xs">${item.current_temp}° → proj ${item.projected_high}°</span>
                        </div>
                        <p class="text-sm text-slate-300 mb-2">
                            Bracket <strong>${item.bucket_base}-${item.bracket_high}°</strong> at risk. Warming <strong>${item.trend_30m.toFixed(1)}°/hr</strong>${item.hours_until_peak > 0 ? ', ' + item.hours_until_peak.toFixed(1) + 'h to peak' : ''}.${consensusLine}
                        </p>
                        <p class="text-xs text-slate-400 mb-2 font-mono">${item.suggested_ticker}</p>
                        <p class="text-slate-300 text-sm mb-1"><strong>NO ask:</strong> ${noAsk}${evCents ? ' <span class="' + (item.ev_cents >= 0 ? 'text-green-400' : 'text-slate-500') + '">' + evCents + '</span>' : ''}</p>
                        <p class="text-amber-400 text-xs font-semibold">BUY NO if you agree temp will exceed ${item.bracket_high}°.</p>
                    </div>
                `;
            });
        }

        // Enable notifications button: request permission upfront
        document.getElementById('enable-notifications-btn')?.addEventListener('click', () => {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            } else if (Notification.permission === 'granted') {
                alert('Desktop notifications are already enabled.');
            }
        });

        // Initial update and poll (5s so positions/prices stay in sync; WebSockets could be added later for real-time)
        updateDashboard();
        setInterval(updateDashboard, 5000);
    </script>
</body>
</html>
